Single-binary Python packaging and distribution.

Platforms like Rust and Go output a single binary by default. This has a number of nice properties:

 * Easier to work with. You only have one thing to upload, copy around, etc.
 * No dependencies. They're all baked right into the binary.

This makes deployment and distribution simpler. You just sling the binary onto your device and run it, no faffing around.

I'm going to show you how to build a single-binary artifact from your Python script.
The artifact will run on any computer which has a `python` binary on the path.
The same binary artifact will run on any version of Python and on any platform with no other dependencies.

### Assumptions & tradeoffs

Unlike Rust and Go we are going to rely on the presence of Python on the target system.
So what we are doing is bundling all of the code and dependencies into the binary but not the Python runtime.
In some ways this is more flexible than architecture specific binaries like those generated by Go and Rust.
We can write programs which target **any version of Python** and ship the same binary.
As long as we a) write portable code b) have a Python executable somewhere on the target machine's path, it will run.
Fortunately most machines these days have some version of Python installed and it's possible to make your package completely version independent.

### Binaries



# The script

Let's start with a very simple script. We'll output some system info and to make things interesting we'll also use a 3rd party Python module.

```
import sh
from sys import version

print("Hello from a Python agnostic binary!")
print("Python version:", version)
print("Uname:", sh.uname("-a"))
```

# Basic setup

requirements.txt
setup.py
setup.cfg

# Build it
